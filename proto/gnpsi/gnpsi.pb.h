// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gnpsi.proto
// Protobuf C++ Version: 4.24.0-main

#ifndef GOOGLE_PROTOBUF_INCLUDED_gnpsi_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_gnpsi_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_gnpsi_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_gnpsi_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_gnpsi_2eproto;
namespace gnpsi {
class IPFIXMetadata;
struct IPFIXMetadataDefaultTypeInternal;
extern IPFIXMetadataDefaultTypeInternal _IPFIXMetadata_default_instance_;
class NetFlowMetadata;
struct NetFlowMetadataDefaultTypeInternal;
extern NetFlowMetadataDefaultTypeInternal _NetFlowMetadata_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class SFlowMetadata;
struct SFlowMetadataDefaultTypeInternal;
extern SFlowMetadataDefaultTypeInternal _SFlowMetadata_default_instance_;
class Sample;
struct SampleDefaultTypeInternal;
extern SampleDefaultTypeInternal _Sample_default_instance_;
}  // namespace gnpsi
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace gnpsi {
enum SFlowMetadata_Version : int {
  SFlowMetadata_Version_UNSPECIFIED = 0,
  SFlowMetadata_Version_V2 = 1,
  SFlowMetadata_Version_V5 = 2,
  SFlowMetadata_Version_SFlowMetadata_Version_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SFlowMetadata_Version_SFlowMetadata_Version_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SFlowMetadata_Version_IsValid(int value);
extern const uint32_t SFlowMetadata_Version_internal_data_[];
constexpr SFlowMetadata_Version SFlowMetadata_Version_Version_MIN = static_cast<SFlowMetadata_Version>(0);
constexpr SFlowMetadata_Version SFlowMetadata_Version_Version_MAX = static_cast<SFlowMetadata_Version>(2);
constexpr int SFlowMetadata_Version_Version_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SFlowMetadata_Version_descriptor();
template <typename T>
const std::string& SFlowMetadata_Version_Name(T value) {
  static_assert(std::is_same<T, SFlowMetadata_Version>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Version_Name().");
  return SFlowMetadata_Version_Name(static_cast<SFlowMetadata_Version>(value));
}
template <>
inline const std::string& SFlowMetadata_Version_Name(SFlowMetadata_Version value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SFlowMetadata_Version_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SFlowMetadata_Version_Parse(absl::string_view name, SFlowMetadata_Version* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SFlowMetadata_Version>(
      SFlowMetadata_Version_descriptor(), name, value);
}
enum NetFlowMetadata_Version : int {
  NetFlowMetadata_Version_UNSPECIFIED = 0,
  NetFlowMetadata_Version_V1 = 1,
  NetFlowMetadata_Version_V5 = 2,
  NetFlowMetadata_Version_V7 = 3,
  NetFlowMetadata_Version_V9 = 4,
  NetFlowMetadata_Version_NetFlowMetadata_Version_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NetFlowMetadata_Version_NetFlowMetadata_Version_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NetFlowMetadata_Version_IsValid(int value);
extern const uint32_t NetFlowMetadata_Version_internal_data_[];
constexpr NetFlowMetadata_Version NetFlowMetadata_Version_Version_MIN = static_cast<NetFlowMetadata_Version>(0);
constexpr NetFlowMetadata_Version NetFlowMetadata_Version_Version_MAX = static_cast<NetFlowMetadata_Version>(4);
constexpr int NetFlowMetadata_Version_Version_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
NetFlowMetadata_Version_descriptor();
template <typename T>
const std::string& NetFlowMetadata_Version_Name(T value) {
  static_assert(std::is_same<T, NetFlowMetadata_Version>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Version_Name().");
  return NetFlowMetadata_Version_Name(static_cast<NetFlowMetadata_Version>(value));
}
template <>
inline const std::string& NetFlowMetadata_Version_Name(NetFlowMetadata_Version value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NetFlowMetadata_Version_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool NetFlowMetadata_Version_Parse(absl::string_view name, NetFlowMetadata_Version* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NetFlowMetadata_Version>(
      NetFlowMetadata_Version_descriptor(), name, value);
}
enum IPFIXMetadata_Version : int {
  IPFIXMetadata_Version_UNSPECIFIED = 0,
  IPFIXMetadata_Version_V10 = 1,
  IPFIXMetadata_Version_IPFIXMetadata_Version_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  IPFIXMetadata_Version_IPFIXMetadata_Version_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool IPFIXMetadata_Version_IsValid(int value);
extern const uint32_t IPFIXMetadata_Version_internal_data_[];
constexpr IPFIXMetadata_Version IPFIXMetadata_Version_Version_MIN = static_cast<IPFIXMetadata_Version>(0);
constexpr IPFIXMetadata_Version IPFIXMetadata_Version_Version_MAX = static_cast<IPFIXMetadata_Version>(1);
constexpr int IPFIXMetadata_Version_Version_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
IPFIXMetadata_Version_descriptor();
template <typename T>
const std::string& IPFIXMetadata_Version_Name(T value) {
  static_assert(std::is_same<T, IPFIXMetadata_Version>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Version_Name().");
  return IPFIXMetadata_Version_Name(static_cast<IPFIXMetadata_Version>(value));
}
template <>
inline const std::string& IPFIXMetadata_Version_Name(IPFIXMetadata_Version value) {
  return ::google::protobuf::internal::NameOfDenseEnum<IPFIXMetadata_Version_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool IPFIXMetadata_Version_Parse(absl::string_view name, IPFIXMetadata_Version* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IPFIXMetadata_Version>(
      IPFIXMetadata_Version_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SFlowMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gnpsi.SFlowMetadata) */ {
 public:
  inline SFlowMetadata() : SFlowMetadata(nullptr) {}
  ~SFlowMetadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SFlowMetadata(::google::protobuf::internal::ConstantInitialized);

  inline SFlowMetadata(const SFlowMetadata& from)
      : SFlowMetadata(nullptr, from) {}
  SFlowMetadata(SFlowMetadata&& from) noexcept
    : SFlowMetadata() {
    *this = ::std::move(from);
  }

  inline SFlowMetadata& operator=(const SFlowMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline SFlowMetadata& operator=(SFlowMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SFlowMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const SFlowMetadata* internal_default_instance() {
    return reinterpret_cast<const SFlowMetadata*>(
               &_SFlowMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SFlowMetadata& a, SFlowMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(SFlowMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SFlowMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SFlowMetadata* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SFlowMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SFlowMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SFlowMetadata& from) {
    SFlowMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SFlowMetadata* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gnpsi.SFlowMetadata";
  }
  protected:
  explicit SFlowMetadata(::google::protobuf::Arena* arena);
  SFlowMetadata(::google::protobuf::Arena* arena, const SFlowMetadata& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Version = SFlowMetadata_Version;
  static constexpr Version UNSPECIFIED = SFlowMetadata_Version_UNSPECIFIED;
  static constexpr Version V2 = SFlowMetadata_Version_V2;
  static constexpr Version V5 = SFlowMetadata_Version_V5;
  static inline bool Version_IsValid(int value) {
    return SFlowMetadata_Version_IsValid(value);
  }
  static constexpr Version Version_MIN = SFlowMetadata_Version_Version_MIN;
  static constexpr Version Version_MAX = SFlowMetadata_Version_Version_MAX;
  static constexpr int Version_ARRAYSIZE = SFlowMetadata_Version_Version_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Version_descriptor() {
    return SFlowMetadata_Version_descriptor();
  }
  template <typename T>
  static inline const std::string& Version_Name(T value) {
    return SFlowMetadata_Version_Name(value);
  }
  static inline bool Version_Parse(absl::string_view name, Version* value) {
    return SFlowMetadata_Version_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // .gnpsi.SFlowMetadata.Version version = 1;
  void clear_version() ;
  ::gnpsi::SFlowMetadata_Version version() const;
  void set_version(::gnpsi::SFlowMetadata_Version value);

  private:
  ::gnpsi::SFlowMetadata_Version _internal_version() const;
  void _internal_set_version(::gnpsi::SFlowMetadata_Version value);

  public:
  // @@protoc_insertion_point(class_scope:gnpsi.SFlowMetadata)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int version_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnpsi_2eproto;
};// -------------------------------------------------------------------

class Request final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:gnpsi.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Request(::google::protobuf::internal::ConstantInitialized);

  inline Request(const Request& from)
      : Request(nullptr, from) {}
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Request& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Request& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gnpsi.Request";
  }
  protected:
  explicit Request(::google::protobuf::Arena* arena);
  Request(::google::protobuf::Arena* arena, const Request& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:gnpsi.Request)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_gnpsi_2eproto;
};// -------------------------------------------------------------------

class NetFlowMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gnpsi.NetFlowMetadata) */ {
 public:
  inline NetFlowMetadata() : NetFlowMetadata(nullptr) {}
  ~NetFlowMetadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NetFlowMetadata(::google::protobuf::internal::ConstantInitialized);

  inline NetFlowMetadata(const NetFlowMetadata& from)
      : NetFlowMetadata(nullptr, from) {}
  NetFlowMetadata(NetFlowMetadata&& from) noexcept
    : NetFlowMetadata() {
    *this = ::std::move(from);
  }

  inline NetFlowMetadata& operator=(const NetFlowMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetFlowMetadata& operator=(NetFlowMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetFlowMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetFlowMetadata* internal_default_instance() {
    return reinterpret_cast<const NetFlowMetadata*>(
               &_NetFlowMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NetFlowMetadata& a, NetFlowMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(NetFlowMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetFlowMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetFlowMetadata* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetFlowMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NetFlowMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NetFlowMetadata& from) {
    NetFlowMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NetFlowMetadata* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gnpsi.NetFlowMetadata";
  }
  protected:
  explicit NetFlowMetadata(::google::protobuf::Arena* arena);
  NetFlowMetadata(::google::protobuf::Arena* arena, const NetFlowMetadata& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Version = NetFlowMetadata_Version;
  static constexpr Version UNSPECIFIED = NetFlowMetadata_Version_UNSPECIFIED;
  static constexpr Version V1 = NetFlowMetadata_Version_V1;
  static constexpr Version V5 = NetFlowMetadata_Version_V5;
  static constexpr Version V7 = NetFlowMetadata_Version_V7;
  static constexpr Version V9 = NetFlowMetadata_Version_V9;
  static inline bool Version_IsValid(int value) {
    return NetFlowMetadata_Version_IsValid(value);
  }
  static constexpr Version Version_MIN = NetFlowMetadata_Version_Version_MIN;
  static constexpr Version Version_MAX = NetFlowMetadata_Version_Version_MAX;
  static constexpr int Version_ARRAYSIZE = NetFlowMetadata_Version_Version_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Version_descriptor() {
    return NetFlowMetadata_Version_descriptor();
  }
  template <typename T>
  static inline const std::string& Version_Name(T value) {
    return NetFlowMetadata_Version_Name(value);
  }
  static inline bool Version_Parse(absl::string_view name, Version* value) {
    return NetFlowMetadata_Version_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // .gnpsi.NetFlowMetadata.Version version = 1;
  void clear_version() ;
  ::gnpsi::NetFlowMetadata_Version version() const;
  void set_version(::gnpsi::NetFlowMetadata_Version value);

  private:
  ::gnpsi::NetFlowMetadata_Version _internal_version() const;
  void _internal_set_version(::gnpsi::NetFlowMetadata_Version value);

  public:
  // @@protoc_insertion_point(class_scope:gnpsi.NetFlowMetadata)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int version_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnpsi_2eproto;
};// -------------------------------------------------------------------

class IPFIXMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gnpsi.IPFIXMetadata) */ {
 public:
  inline IPFIXMetadata() : IPFIXMetadata(nullptr) {}
  ~IPFIXMetadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IPFIXMetadata(::google::protobuf::internal::ConstantInitialized);

  inline IPFIXMetadata(const IPFIXMetadata& from)
      : IPFIXMetadata(nullptr, from) {}
  IPFIXMetadata(IPFIXMetadata&& from) noexcept
    : IPFIXMetadata() {
    *this = ::std::move(from);
  }

  inline IPFIXMetadata& operator=(const IPFIXMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPFIXMetadata& operator=(IPFIXMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPFIXMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPFIXMetadata* internal_default_instance() {
    return reinterpret_cast<const IPFIXMetadata*>(
               &_IPFIXMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(IPFIXMetadata& a, IPFIXMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(IPFIXMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPFIXMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPFIXMetadata* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPFIXMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IPFIXMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const IPFIXMetadata& from) {
    IPFIXMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IPFIXMetadata* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gnpsi.IPFIXMetadata";
  }
  protected:
  explicit IPFIXMetadata(::google::protobuf::Arena* arena);
  IPFIXMetadata(::google::protobuf::Arena* arena, const IPFIXMetadata& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Version = IPFIXMetadata_Version;
  static constexpr Version UNSPECIFIED = IPFIXMetadata_Version_UNSPECIFIED;
  static constexpr Version V10 = IPFIXMetadata_Version_V10;
  static inline bool Version_IsValid(int value) {
    return IPFIXMetadata_Version_IsValid(value);
  }
  static constexpr Version Version_MIN = IPFIXMetadata_Version_Version_MIN;
  static constexpr Version Version_MAX = IPFIXMetadata_Version_Version_MAX;
  static constexpr int Version_ARRAYSIZE = IPFIXMetadata_Version_Version_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Version_descriptor() {
    return IPFIXMetadata_Version_descriptor();
  }
  template <typename T>
  static inline const std::string& Version_Name(T value) {
    return IPFIXMetadata_Version_Name(value);
  }
  static inline bool Version_Parse(absl::string_view name, Version* value) {
    return IPFIXMetadata_Version_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // .gnpsi.IPFIXMetadata.Version version = 1;
  void clear_version() ;
  ::gnpsi::IPFIXMetadata_Version version() const;
  void set_version(::gnpsi::IPFIXMetadata_Version value);

  private:
  ::gnpsi::IPFIXMetadata_Version _internal_version() const;
  void _internal_set_version(::gnpsi::IPFIXMetadata_Version value);

  public:
  // @@protoc_insertion_point(class_scope:gnpsi.IPFIXMetadata)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int version_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnpsi_2eproto;
};// -------------------------------------------------------------------

class Sample final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gnpsi.Sample) */ {
 public:
  inline Sample() : Sample(nullptr) {}
  ~Sample() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Sample(::google::protobuf::internal::ConstantInitialized);

  inline Sample(const Sample& from)
      : Sample(nullptr, from) {}
  Sample(Sample&& from) noexcept
    : Sample() {
    *this = ::std::move(from);
  }

  inline Sample& operator=(const Sample& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sample& operator=(Sample&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sample& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sample* internal_default_instance() {
    return reinterpret_cast<const Sample*>(
               &_Sample_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Sample& a, Sample& b) {
    a.Swap(&b);
  }
  inline void Swap(Sample* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sample* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sample* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sample>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Sample& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Sample& from) {
    Sample::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Sample* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "gnpsi.Sample";
  }
  protected:
  explicit Sample(::google::protobuf::Arena* arena);
  Sample(::google::protobuf::Arena* arena, const Sample& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketFieldNumber = 1,
    kSflowMetadataFieldNumber = 101,
    kNetflowMetadataFieldNumber = 102,
    kIpfixMetadataFieldNumber = 103,
    kTimestampFieldNumber = 2,
  };
  // bytes packet = 1;
  void clear_packet() ;
  const std::string& packet() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_packet(Arg_&& arg, Args_... args);
  std::string* mutable_packet();
  PROTOBUF_NODISCARD std::string* release_packet();
  void set_allocated_packet(std::string* value);

  private:
  const std::string& _internal_packet() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_packet(
      const std::string& value);
  std::string* _internal_mutable_packet();

  public:
  // .gnpsi.SFlowMetadata sflow_metadata = 101;
  bool has_sflow_metadata() const;
  void clear_sflow_metadata() ;
  const ::gnpsi::SFlowMetadata& sflow_metadata() const;
  PROTOBUF_NODISCARD ::gnpsi::SFlowMetadata* release_sflow_metadata();
  ::gnpsi::SFlowMetadata* mutable_sflow_metadata();
  void set_allocated_sflow_metadata(::gnpsi::SFlowMetadata* value);
  void unsafe_arena_set_allocated_sflow_metadata(::gnpsi::SFlowMetadata* value);
  ::gnpsi::SFlowMetadata* unsafe_arena_release_sflow_metadata();

  private:
  const ::gnpsi::SFlowMetadata& _internal_sflow_metadata() const;
  ::gnpsi::SFlowMetadata* _internal_mutable_sflow_metadata();

  public:
  // .gnpsi.NetFlowMetadata netflow_metadata = 102;
  bool has_netflow_metadata() const;
  void clear_netflow_metadata() ;
  const ::gnpsi::NetFlowMetadata& netflow_metadata() const;
  PROTOBUF_NODISCARD ::gnpsi::NetFlowMetadata* release_netflow_metadata();
  ::gnpsi::NetFlowMetadata* mutable_netflow_metadata();
  void set_allocated_netflow_metadata(::gnpsi::NetFlowMetadata* value);
  void unsafe_arena_set_allocated_netflow_metadata(::gnpsi::NetFlowMetadata* value);
  ::gnpsi::NetFlowMetadata* unsafe_arena_release_netflow_metadata();

  private:
  const ::gnpsi::NetFlowMetadata& _internal_netflow_metadata() const;
  ::gnpsi::NetFlowMetadata* _internal_mutable_netflow_metadata();

  public:
  // .gnpsi.IPFIXMetadata ipfix_metadata = 103;
  bool has_ipfix_metadata() const;
  void clear_ipfix_metadata() ;
  const ::gnpsi::IPFIXMetadata& ipfix_metadata() const;
  PROTOBUF_NODISCARD ::gnpsi::IPFIXMetadata* release_ipfix_metadata();
  ::gnpsi::IPFIXMetadata* mutable_ipfix_metadata();
  void set_allocated_ipfix_metadata(::gnpsi::IPFIXMetadata* value);
  void unsafe_arena_set_allocated_ipfix_metadata(::gnpsi::IPFIXMetadata* value);
  ::gnpsi::IPFIXMetadata* unsafe_arena_release_ipfix_metadata();

  private:
  const ::gnpsi::IPFIXMetadata& _internal_ipfix_metadata() const;
  ::gnpsi::IPFIXMetadata* _internal_mutable_ipfix_metadata();

  public:
  // int64 timestamp = 2;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:gnpsi.Sample)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr packet_;
    ::gnpsi::SFlowMetadata* sflow_metadata_;
    ::gnpsi::NetFlowMetadata* netflow_metadata_;
    ::gnpsi::IPFIXMetadata* ipfix_metadata_;
    ::int64_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gnpsi_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SFlowMetadata

// .gnpsi.SFlowMetadata.Version version = 1;
inline void SFlowMetadata::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_ = 0;
}
inline ::gnpsi::SFlowMetadata_Version SFlowMetadata::version() const {
  // @@protoc_insertion_point(field_get:gnpsi.SFlowMetadata.version)
  return _internal_version();
}
inline void SFlowMetadata::set_version(::gnpsi::SFlowMetadata_Version value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:gnpsi.SFlowMetadata.version)
}
inline ::gnpsi::SFlowMetadata_Version SFlowMetadata::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::gnpsi::SFlowMetadata_Version>(_impl_.version_);
}
inline void SFlowMetadata::_internal_set_version(::gnpsi::SFlowMetadata_Version value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_ = value;
}

// -------------------------------------------------------------------

// NetFlowMetadata

// .gnpsi.NetFlowMetadata.Version version = 1;
inline void NetFlowMetadata::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_ = 0;
}
inline ::gnpsi::NetFlowMetadata_Version NetFlowMetadata::version() const {
  // @@protoc_insertion_point(field_get:gnpsi.NetFlowMetadata.version)
  return _internal_version();
}
inline void NetFlowMetadata::set_version(::gnpsi::NetFlowMetadata_Version value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:gnpsi.NetFlowMetadata.version)
}
inline ::gnpsi::NetFlowMetadata_Version NetFlowMetadata::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::gnpsi::NetFlowMetadata_Version>(_impl_.version_);
}
inline void NetFlowMetadata::_internal_set_version(::gnpsi::NetFlowMetadata_Version value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_ = value;
}

// -------------------------------------------------------------------

// IPFIXMetadata

// .gnpsi.IPFIXMetadata.Version version = 1;
inline void IPFIXMetadata::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_ = 0;
}
inline ::gnpsi::IPFIXMetadata_Version IPFIXMetadata::version() const {
  // @@protoc_insertion_point(field_get:gnpsi.IPFIXMetadata.version)
  return _internal_version();
}
inline void IPFIXMetadata::set_version(::gnpsi::IPFIXMetadata_Version value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:gnpsi.IPFIXMetadata.version)
}
inline ::gnpsi::IPFIXMetadata_Version IPFIXMetadata::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::gnpsi::IPFIXMetadata_Version>(_impl_.version_);
}
inline void IPFIXMetadata::_internal_set_version(::gnpsi::IPFIXMetadata_Version value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_ = value;
}

// -------------------------------------------------------------------

// Request

// -------------------------------------------------------------------

// Sample

// bytes packet = 1;
inline void Sample::clear_packet() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_.ClearToEmpty();
}
inline const std::string& Sample::packet() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gnpsi.Sample.packet)
  return _internal_packet();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Sample::set_packet(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.packet_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gnpsi.Sample.packet)
}
inline std::string* Sample::mutable_packet() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_packet();
  // @@protoc_insertion_point(field_mutable:gnpsi.Sample.packet)
  return _s;
}
inline const std::string& Sample::_internal_packet() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packet_.Get();
}
inline void Sample::_internal_set_packet(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.packet_.Set(value, GetArena());
}
inline std::string* Sample::_internal_mutable_packet() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.packet_.Mutable( GetArena());
}
inline std::string* Sample::release_packet() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gnpsi.Sample.packet)
  return _impl_.packet_.Release();
}
inline void Sample::set_allocated_packet(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.packet_.IsDefault()) {
          _impl_.packet_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnpsi.Sample.packet)
}

// int64 timestamp = 2;
inline void Sample::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t Sample::timestamp() const {
  // @@protoc_insertion_point(field_get:gnpsi.Sample.timestamp)
  return _internal_timestamp();
}
inline void Sample::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:gnpsi.Sample.timestamp)
}
inline ::int64_t Sample::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void Sample::_internal_set_timestamp(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// .gnpsi.SFlowMetadata sflow_metadata = 101;
inline bool Sample::has_sflow_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sflow_metadata_ != nullptr);
  return value;
}
inline void Sample::clear_sflow_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.sflow_metadata_ != nullptr) _impl_.sflow_metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::gnpsi::SFlowMetadata& Sample::_internal_sflow_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::gnpsi::SFlowMetadata* p = _impl_.sflow_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnpsi::SFlowMetadata&>(::gnpsi::_SFlowMetadata_default_instance_);
}
inline const ::gnpsi::SFlowMetadata& Sample::sflow_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gnpsi.Sample.sflow_metadata)
  return _internal_sflow_metadata();
}
inline void Sample::unsafe_arena_set_allocated_sflow_metadata(::gnpsi::SFlowMetadata* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sflow_metadata_);
  }
  _impl_.sflow_metadata_ = reinterpret_cast<::gnpsi::SFlowMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnpsi.Sample.sflow_metadata)
}
inline ::gnpsi::SFlowMetadata* Sample::release_sflow_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gnpsi::SFlowMetadata* released = _impl_.sflow_metadata_;
  _impl_.sflow_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::gnpsi::SFlowMetadata* Sample::unsafe_arena_release_sflow_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gnpsi.Sample.sflow_metadata)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::gnpsi::SFlowMetadata* temp = _impl_.sflow_metadata_;
  _impl_.sflow_metadata_ = nullptr;
  return temp;
}
inline ::gnpsi::SFlowMetadata* Sample::_internal_mutable_sflow_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sflow_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnpsi::SFlowMetadata>(GetArena());
    _impl_.sflow_metadata_ = reinterpret_cast<::gnpsi::SFlowMetadata*>(p);
  }
  return _impl_.sflow_metadata_;
}
inline ::gnpsi::SFlowMetadata* Sample::mutable_sflow_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::gnpsi::SFlowMetadata* _msg = _internal_mutable_sflow_metadata();
  // @@protoc_insertion_point(field_mutable:gnpsi.Sample.sflow_metadata)
  return _msg;
}
inline void Sample::set_allocated_sflow_metadata(::gnpsi::SFlowMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.sflow_metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.sflow_metadata_ = reinterpret_cast<::gnpsi::SFlowMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:gnpsi.Sample.sflow_metadata)
}

// .gnpsi.NetFlowMetadata netflow_metadata = 102;
inline bool Sample::has_netflow_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.netflow_metadata_ != nullptr);
  return value;
}
inline void Sample::clear_netflow_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.netflow_metadata_ != nullptr) _impl_.netflow_metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::gnpsi::NetFlowMetadata& Sample::_internal_netflow_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::gnpsi::NetFlowMetadata* p = _impl_.netflow_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnpsi::NetFlowMetadata&>(::gnpsi::_NetFlowMetadata_default_instance_);
}
inline const ::gnpsi::NetFlowMetadata& Sample::netflow_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gnpsi.Sample.netflow_metadata)
  return _internal_netflow_metadata();
}
inline void Sample::unsafe_arena_set_allocated_netflow_metadata(::gnpsi::NetFlowMetadata* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.netflow_metadata_);
  }
  _impl_.netflow_metadata_ = reinterpret_cast<::gnpsi::NetFlowMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnpsi.Sample.netflow_metadata)
}
inline ::gnpsi::NetFlowMetadata* Sample::release_netflow_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::gnpsi::NetFlowMetadata* released = _impl_.netflow_metadata_;
  _impl_.netflow_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::gnpsi::NetFlowMetadata* Sample::unsafe_arena_release_netflow_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gnpsi.Sample.netflow_metadata)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::gnpsi::NetFlowMetadata* temp = _impl_.netflow_metadata_;
  _impl_.netflow_metadata_ = nullptr;
  return temp;
}
inline ::gnpsi::NetFlowMetadata* Sample::_internal_mutable_netflow_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.netflow_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnpsi::NetFlowMetadata>(GetArena());
    _impl_.netflow_metadata_ = reinterpret_cast<::gnpsi::NetFlowMetadata*>(p);
  }
  return _impl_.netflow_metadata_;
}
inline ::gnpsi::NetFlowMetadata* Sample::mutable_netflow_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::gnpsi::NetFlowMetadata* _msg = _internal_mutable_netflow_metadata();
  // @@protoc_insertion_point(field_mutable:gnpsi.Sample.netflow_metadata)
  return _msg;
}
inline void Sample::set_allocated_netflow_metadata(::gnpsi::NetFlowMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.netflow_metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.netflow_metadata_ = reinterpret_cast<::gnpsi::NetFlowMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:gnpsi.Sample.netflow_metadata)
}

// .gnpsi.IPFIXMetadata ipfix_metadata = 103;
inline bool Sample::has_ipfix_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ipfix_metadata_ != nullptr);
  return value;
}
inline void Sample::clear_ipfix_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ipfix_metadata_ != nullptr) _impl_.ipfix_metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::gnpsi::IPFIXMetadata& Sample::_internal_ipfix_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::gnpsi::IPFIXMetadata* p = _impl_.ipfix_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnpsi::IPFIXMetadata&>(::gnpsi::_IPFIXMetadata_default_instance_);
}
inline const ::gnpsi::IPFIXMetadata& Sample::ipfix_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gnpsi.Sample.ipfix_metadata)
  return _internal_ipfix_metadata();
}
inline void Sample::unsafe_arena_set_allocated_ipfix_metadata(::gnpsi::IPFIXMetadata* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ipfix_metadata_);
  }
  _impl_.ipfix_metadata_ = reinterpret_cast<::gnpsi::IPFIXMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnpsi.Sample.ipfix_metadata)
}
inline ::gnpsi::IPFIXMetadata* Sample::release_ipfix_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::gnpsi::IPFIXMetadata* released = _impl_.ipfix_metadata_;
  _impl_.ipfix_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::gnpsi::IPFIXMetadata* Sample::unsafe_arena_release_ipfix_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gnpsi.Sample.ipfix_metadata)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::gnpsi::IPFIXMetadata* temp = _impl_.ipfix_metadata_;
  _impl_.ipfix_metadata_ = nullptr;
  return temp;
}
inline ::gnpsi::IPFIXMetadata* Sample::_internal_mutable_ipfix_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.ipfix_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnpsi::IPFIXMetadata>(GetArena());
    _impl_.ipfix_metadata_ = reinterpret_cast<::gnpsi::IPFIXMetadata*>(p);
  }
  return _impl_.ipfix_metadata_;
}
inline ::gnpsi::IPFIXMetadata* Sample::mutable_ipfix_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::gnpsi::IPFIXMetadata* _msg = _internal_mutable_ipfix_metadata();
  // @@protoc_insertion_point(field_mutable:gnpsi.Sample.ipfix_metadata)
  return _msg;
}
inline void Sample::set_allocated_ipfix_metadata(::gnpsi::IPFIXMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.ipfix_metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.ipfix_metadata_ = reinterpret_cast<::gnpsi::IPFIXMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:gnpsi.Sample.ipfix_metadata)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace gnpsi


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::gnpsi::SFlowMetadata_Version> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::gnpsi::SFlowMetadata_Version>() {
  return ::gnpsi::SFlowMetadata_Version_descriptor();
}
template <>
struct is_proto_enum<::gnpsi::NetFlowMetadata_Version> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::gnpsi::NetFlowMetadata_Version>() {
  return ::gnpsi::NetFlowMetadata_Version_descriptor();
}
template <>
struct is_proto_enum<::gnpsi::IPFIXMetadata_Version> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::gnpsi::IPFIXMetadata_Version>() {
  return ::gnpsi::IPFIXMetadata_Version_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_gnpsi_2eproto_2epb_2eh
